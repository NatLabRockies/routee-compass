use crate::{
    algorithm::search::{Direction, EdgeTraversal, SearchError, SearchTree},
    model::{
        constraint::ConstraintModel,
        cost::CostModel,
        label::{label_model::LabelModel, Label},
        map::MapModel,
        network::{EdgeId, EdgeListId, Graph},
        state::StateModel,
        termination::TerminationModel,
        traversal::TraversalModel,
    },
};
use std::sync::Arc;

/// instances of read-only objects used for a search that have
/// been prepared for a specific query.
pub struct SearchInstance {
    pub graph: Arc<Graph>,
    pub constraint_models: Vec<Arc<dyn ConstraintModel>>,
    pub traversal_models: Vec<Arc<dyn TraversalModel>>,
    pub map_model: Arc<MapModel>,
    pub state_model: Arc<StateModel>,
    pub cost_model: Arc<CostModel>,
    pub termination_model: Arc<TerminationModel>,
    pub label_model: Arc<dyn LabelModel>,
    pub default_edge_list: Option<usize>,
}

impl SearchInstance {
    /// in the case of traversal estimation, where no edges are used, divert to the traversal model
    /// associated with the default edge list
    pub fn get_traversal_estimation_model(&self) -> Arc<dyn TraversalModel> {
        self.traversal_models[self.default_edge_list.unwrap_or_default()].clone()
    }

    pub fn get_constraint_model(
        &self,
        edge_list_id: &EdgeListId,
    ) -> Result<Arc<dyn ConstraintModel>, SearchError> {
        self.constraint_models
            .get(edge_list_id.0)
            .ok_or_else(|| SearchError::InternalError(format!("during search, attempting to retrieve constraint models for edge list {edge_list_id} that does not exist")))
            .cloned()
    }

    pub fn get_traversal_model(
        &self,
        edge_list_id: &EdgeListId,
    ) -> Result<Arc<dyn TraversalModel>, SearchError> {
        self.traversal_models
            .get(edge_list_id.0)
            .ok_or_else(|| SearchError::InternalError(format!("during search, attempting to retrieve traversal models for edge list {edge_list_id} that does not exist")))
            .cloned()
    }

    /// recalculates the edge traversals for a given path of edge IDs.
    /// this is useful for updating the state of a path that was
    /// generated by a map matching algorithm or some other process
    /// that does not maintain the full search state.
    pub fn recalculate_path(
        &self,
        path: &[(EdgeListId, EdgeId)],
    ) -> Result<Vec<EdgeTraversal>, SearchError> {
        let mut edge_traversals = Vec::with_capacity(path.len());
        let mut current_state = self.state_model.initial_state(None)?;
        let mut tree = SearchTree::new(Direction::Forward);

        let mut prev_label = if let Some((edge_list_id, edge_id)) = path.first() {
            let (src, _, _) = self.graph.edge_triplet(edge_list_id, edge_id)?;
            let root_label = Label::Vertex(src.vertex_id);
            tree.set_root(root_label.clone());
            root_label
        } else {
            return Ok(Vec::new());
        };

        for (i, (edge_list_id, edge_id)) in path.iter().enumerate() {
            let trajectory = self.graph.edge_triplet(edge_list_id, edge_id)?;
            let (_, _, dst) = trajectory;
            let tm = self.get_traversal_model(edge_list_id)?;

            let traversal = EdgeTraversal::new_local(
                trajectory,
                &tree,
                &current_state,
                &self.state_model,
                tm.as_ref(),
                &self.cost_model,
            )?;

            // Use indexed labels to handle cycles in the path correctly
            let child_label = Label::VertexWithIntState {
                vertex_id: dst.vertex_id,
                state: i,
            };
            tree.insert(prev_label, traversal.clone(), child_label.clone())
                .map_err(|e| SearchError::InternalError(e.to_string()))?;

            prev_label = child_label;
            current_state = traversal.result_state.clone();
            edge_traversals.push(traversal);
        }

        Ok(edge_traversals)
    }
}
